/**
 * C++ inference test for equivalence validation.
 *
 * This program loads test inputs from JSON file (generated by Python),
 * runs inference using C++ ONNX Runtime, and outputs results in a format
 * that Python can parse and compare.
 */

#include "../include/shared_model_inferencer.hpp"
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <string>
#include <cstdlib>


// Simple JSON parsing for test data (no external dependencies)
std::vector<int64_t> parse_int64_array(const std::string& json_array)
{
	std::vector<int64_t> result;
	std::istringstream iss(json_array);
	char c;
	int64_t val;

	while (iss >> c || !iss.eof())
	{
		if (iss >> val)
		{
			result.push_back(val);
		}
	}

	return result;
}


std::vector<float> parse_float_array(const std::string& json_array)
{
	std::vector<float> result;
	std::istringstream iss(json_array);
	char c;
	float val;

	while (iss >> c || !iss.eof())
	{
		if (iss >> val)
		{
			result.push_back(val);
		}
	}

	return result;
}


std::string extract_json_value(const std::string& json, const std::string& key)
{
	// Find key
	std::string search_key = "\"" + key + "\":";
	size_t key_pos = json.find(search_key);
	if (key_pos == std::string::npos)
	{
		return "";
	}

	size_t value_start = key_pos + search_key.length();

	// Skip whitespace
	while (value_start < json.length() && std::isspace(json[value_start]))
	{
		value_start++;
	}

	// Determine value type and extract
	if (json[value_start] == '"')
	{
		// String value
		value_start++;
		size_t value_end = json.find('"', value_start);
		return json.substr(value_start, value_end - value_start);
	}
	else if (json[value_start] == '[')
	{
		// Array value
		int bracket_count = 0;
		size_t value_end = value_start;
		do
		{
			if (json[value_end] == '[') bracket_count++;
			if (json[value_end] == ']') bracket_count--;
			value_end++;
		}
		while (bracket_count > 0 && value_end < json.length());

		return json.substr(value_start, value_end - value_start);
	}

	return "";
}


int main(int argc, char* argv[])
{
	if (argc < 2)
	{
		std::cerr << "Usage: " << argv[0] << " <test_data.json>" << std::endl;
		return 1;
	}

	try
	{
		// Load test data JSON
		std::ifstream file(argv[1]);
		if (!file.is_open())
		{
			std::cerr << "Failed to open test data file: " << argv[1] << std::endl;
			return 1;
		}

		std::stringstream buffer;
		buffer << file.rdbuf();
		std::string json = buffer.str();

		// Extract values
		std::string base_path = extract_json_value(json, "base_path");
		std::string policy_path = extract_json_value(json, "policy_path");
		std::string value_path = extract_json_value(json, "value_path");

		auto prefix_ids = parse_int64_array(extract_json_value(json, "prefix_ids"));
		auto evaluated_ids = parse_int64_array(extract_json_value(json, "evaluated_ids"));
		auto evaluated_mask = parse_float_array(extract_json_value(json, "evaluated_mask"));
		auto input_ids = parse_int64_array(extract_json_value(json, "input_ids"));

		// Dimensions (fixed for test model)
		int batch_size = 1;
		int prefix_len = 128;
		int eval_len = 64;
		int seq_len = 191;

		// Create inferencer
		trigo::SharedModelInferencer inferencer(base_path, policy_path, value_path, false);

		// Run policy inference
		auto policy_logits = inferencer.policy_inference(
			prefix_ids,
			evaluated_ids,
			evaluated_mask,
			batch_size,
			prefix_len,
			eval_len
		);

		// Run value inference
		auto values = inferencer.value_inference(input_ids, batch_size, seq_len, 3);

		// Output results in parseable format
		std::cout << "POLICY_LOGITS:";
		for (size_t i = 0; i < std::min(size_t(100), policy_logits.size()); i++)
		{
			std::cout << " " << policy_logits[i];
		}
		std::cout << std::endl;

		std::cout << "VALUE: " << values[0] << std::endl;

		return 0;
	}
	catch (const std::exception& e)
	{
		std::cerr << "Error: " << e.what() << std::endl;
		return 1;
	}
}
